# 优化协议细节

此阶段针对 API_DESIGN 进行整体修正和优化。

# 历史记录

## 1. 重新设计 API_DESIGN 中的定义

```markdown
我正在开发一个 Rust 异步 RPC + Stream 双向调用传输系统，支持中间件和插件。

项目信息：

下面是初步的系统模块划分和 API 设计文档，请你分析下面完整的 API 设计：

- 重构当前的模块划分和每个子模块的职责。
- 细化明确每个子模块中的 Struct、类型、方法和接口定义

请给出完整的重构细化后的完整版的整个系统的模块设计和每个子模块的具体设计（所有核心细节和公开模块/方法定义）。

重要的是定义清晰模块、调用 API、类型和放置位置等完整细节，作为整个项目最核心细致的开发 spec，像 proposal 一样清晰可实现。
```

核心待明确的模块：

- Frame
  - Metadata
    - 可扩展元数据，类似 http 的 header
    - 比如 token 认证，lang 多语言等信息，用于全局消息处理逻辑等
  - Payload
    - Request
      - id
      - name
      - data
    - Response
      - id 对应的请求 id，用于回复
      - data
      - code
      - message
    - Event
      - id
      - name
      - data
    - Stream
      - id 对应流的 id，非当前流的帧的 id
      - name
      - seq // 帧 id 
      - timestamp //  当前帧对应的目标时间
      - data
    - Ping/Pong 心跳与节点间时间同步
- Context // client 和 server 的应用级别的上下文
  - start 开始运行
  - stop 结束运行
  - on_start
  - on_stop
  - on_error
  - set 设置上下文状态（自定义 key 和类型
  - get 获取上下文状态（自定义 key 和类型
- Session
  - connect 连接
  - disconnect 断开连接
  - on_connect
  - on_disconnect 
  - on_error
  - request 发送 rpc 请求
  - emit 发送 event 事件
  - write 发送 stream 数据帧
  - set 设置会话状态（自定义 key 和类型
  - get 获取会话状态（自定义 key 和类型
  - ctx 获取当前会话的 context
- Client + builder
- Server + builder
- RPC
  - on_request // 发起 RPC 请求，并异步等待响应，支持超时处理和是否阻塞运行
  - on_response // 收到 RPC 回应，resolve 等待中的 future
- Event // event bus
  - emit
  - subscribe
  - unsubscribe
  - once
- Handler
  - RpcHandler
    - name
    - setup
  - EventHandler
  - StreamHandler
- derive
  - rpc
  - event
  - stream
- Error
- Middleware
  - 针对“消息内容”，它可以修改请求包、拦截请求、记录耗时，是 数据面 的扩展。
- Plugin
  - 针对“连接生命周期+client/server 生命周期”，它关注连接何时建立、何时出错、何时关闭，是 控制面 的扩展，可以打包一些常用 handler 等操作，构成集合。

```markdown
请帮我设计一个基于 QUIC 的高性能异步双向 RPC 和流传输框架，让实时通信像写本地函数一样简单。专为实时通信场景设计的 Rust RPC 框架，融合传统 RPC 的便利性和实时流传输能力，通过 QUIC 协议在单连接上同时处理控制信令和实时数据流。

下面是我对一些核心模块的API设想，请你继续完善各个类型，模块，API，参数等的设计架构和细化，并给出完整的文档（系统架构proposal实施细节）
```